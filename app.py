from flask import Flask, render_template, request, jsonify
import dns.resolver
import dns.zone
import dns.query
import dns.rdatatype
import json
from io import StringIO
import whois  # New import for WHOIS functionality
from datetime import datetime  # For date handling in WHOIS results

app = Flask(__name__)

def get_dns_records(domain, nameserver=None):
    """Fetch DNS records from a domain"""
    records = {
        'A': [],
        'AAAA': [],
        'CNAME': [],
        'MX': [],
        'TXT': [],
        'NS': [],
        'SRV': [],
        'CAA': []
    }
    
    resolver = dns.resolver.Resolver()
    if nameserver:
        resolver.nameservers = [nameserver]
    
    # Try zone transfer first (AXFR)
    try:
        zone = dns.zone.from_xfr(dns.query.xfr(nameserver or '', domain))
        for name, node in zone.nodes.items():
            for rdataset in node.rdatasets:
                for rdata in rdataset:
                    record_type = dns.rdatatype.to_text(rdataset.rdtype)
                    if record_type in records:
                        records[record_type].append({
                            'name': str(name) if str(name) != '@' else domain,
                            'value': str(rdata),
                            'ttl': rdataset.ttl
                        })
        return records
    except Exception as e:
        print(f"Zone transfer failed: {e}. Falling back to individual queries.")
    
    # Fallback to individual queries if zone transfer fails
    for record_type in records.keys():
        try:
            answers = resolver.resolve(domain, record_type)
            for rdata in answers:
                value = str(rdata)
                if record_type == 'MX':
                    value = f"{rdata.preference} {rdata.exchange}"
                records[record_type].append({
                    'name': domain,
                    'value': value,
                    'ttl': answers.rrset.ttl if hasattr(answers, 'rrset') else 3600
                })
        except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN):
            continue
        except Exception as e:
            print(f"Error fetching {record_type} records: {e}")
    
    return records

def get_whois_info(domain):
    """Perform WHOIS lookup for a domain"""
    try:
        domain_info = whois.whois(domain)
        
        # Convert dates to strings for JSON serialization
        def process_dates(obj):
            if isinstance(obj, datetime):
                return obj.strftime('%Y-%m-%d %H:%M:%S')
            elif isinstance(obj, list):
                return [process_dates(item) for item in obj]
            elif isinstance(obj, dict):
                return {k: process_dates(v) for k, v in obj.items()}
            return obj
        
        # Process the WHOIS data to make it JSON serializable
        whois_data = {}
        for key, value in domain_info.items():
            whois_data[key] = process_dates(value)
        
        return whois_data
    except Exception as e:
        print(f"WHOIS lookup failed: {e}")
        return {"error": str(e)}

def convert_to_cloudflare_yaml(records, domain):
    """Convert DNS records to Cloudflare YAML format"""
    output = StringIO()
    output.write(f"# Cloudflare DNS records for {domain}\n")
    output.write("# Generated by DNS to Cloudflare converter\n\n")
    
    for record_type, entries in records.items():
        if not entries:
            continue
            
        for entry in entries:
            name = entry['name']
            if name.endswith(f".{domain}"):
                name = name[:-len(f".{domain}")]
            if name == domain:
                name = "@"
            
            output.write(f"- name: {name}\n")
            output.write(f"  type: {record_type}\n")
            output.write(f"  ttl: {entry['ttl']}\n")
            
            if record_type == 'MX':
                preference, exchange = entry['value'].split(' ', 1)
                output.write(f"  priority: {preference}\n")
                output.write(f"  value: {exchange}\n")
            elif record_type == 'SRV':
                parts = entry['value'].split()
                if len(parts) >= 4:
                    output.write(f"  priority: {parts[0]}\n")
                    output.write(f"  weight: {parts[1]}\n")
                    output.write(f"  port: {parts[2]}\n")
                    output.write(f"  target: {' '.join(parts[3:])}\n")
            elif record_type == 'CAA':
                parts = entry['value'].split()
                if len(parts) >= 2:
                    output.write(f"  flags: {parts[0]}\n")
                    output.write(f"  tag: {parts[1]}\n")
                    output.write(f"  value: {' '.join(parts[2:])}\n")
            else:
                output.write(f"  value: {entry['value']}\n")
            
            output.write("\n")
    
    return output.getvalue()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/extract', methods=['POST'])
def extract_dns():
    data = request.json
    domain = data.get('domain')
    nameserver = data.get('nameserver')
    
    if not domain:
        return jsonify({'error': 'Domain is required'}), 400
    
    try:
        records = get_dns_records(domain, nameserver)
        cloudflare_yaml = convert_to_cloudflare_yaml(records, domain)
        whois_info = get_whois_info(domain)
        
        return jsonify({
            'success': True,
            'yaml': cloudflare_yaml,
            'records': records,
            'whois': whois_info
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=10000)